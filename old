static DOCUMENT_ROOT: &'static str = "/home/mavr/http-test";


                // let mut data = None;
                // if need_to_read {
                    // let mut bytes = Vec::new();
                    // let mut file = File::open(path).unwrap();
                    // file.read_to_end(&mut bytes);
                    // data = Some(bytes);
                // }



                            //FileHandler::get_http_ext(path.extension().unwrap().to_str().unwrap())
// use std::collections::V;


        // let body_exist = self.body_exist.clone();
        // let mut terminator = HTTP_TERMINATOR.to_owned();
        // if !body_exist {
            // headers_string += HTTP_TERMINATOR;
        // }


        // let mut resp_byte = Vec::new();
        // resp_byte.append(&mut response_string.into_bytes());

// use nix::unistd::close;X?S


    // let res = panic::catch_unwind(|| {

      // break;
                    // return Err(Sys(err));



                            // println!("{:?}", err);
                            // panic!();
                            // return Err(err);
                            // panic!();

        // );
        // }

                //     if err == Errno::EAGAIN {
                //         return Ok(self.state.clone());
                //     }
                //         return Ok(self.state.clone());

                //     // return Err(Sys(err));
                // },
                // Err(err) => {
                //         return Ok(self.state.clone());

                //     // return Err(err)
                // }




            // let mut offt = self.file_sended as i64; 
            // let need_to_send = self.file_len - self.file_sended;

            // let to_send = match FILE_BUF < need_to_send {
            //     true => FILE_BUF,
            //     false => need_to_send
            // };


// 26602944989
// 26718100000
                    // println!("{:?}", str::from_utf8(self.buffer_write.as_slice()));


    // fn handle(&mut self, flg: EpollFlags) {
    //     if self.state == ClientState::READING {
    //         if self.interest == self.interest & EpollFlags::EPOLLIN {
    //             self.read();
    //         }
    //     }
    // } 


        // fn create_response_part(req: &HttpRequest, is_get: bool) -> HttpResponse {
    //     let mut path_to_file = req.uri.clone();
    //     match FileHandler::get_file(&mut path_to_file, is_get) {
    //         Ok(value) => {
    //             let (body, size, ext) = value;
    //             let mut headers: HashMap<String, String> = HashMap::new();
    //             headers.insert(String::from("Content-type"), ext);
    //             headers.insert(String::from("Content-Length"), size.to_string());
    //             return HttpResponse::ok(headers, None);
    //         },
    //         Err(is_forbidden) => {
    //             let status = match is_forbidden {
    //                 true => return HttpResponse::forbidden(),
    //                 false => return HttpResponse::not_found()
    //             };
    //         }
    //     }
    // }

    // fn create_response(req: &HttpRequest) -> HttpResponse {
    //     match req.method.as_ref() {
    //         "GET" => return HttpClient::create_response_part(req, true),
    //         "HEAD" => return HttpClient::create_response_part(req, false), 
    //         _ => return HttpResponse::not_allowed()
    //     }
    // }


    // let buffer = [0; BUFSIZE];

    // let mut clients: HashMap<RawFd, Client> = HashMap::new();//SockFlag::EPOLLET



    // let ac = vec![1, 2, 3];

    // let bc = ac.as_slice();
    // let cc = bc[1..].len();
    // println!("{:?}", cc);



// const BUFSIZE: usize =  16384;
// #[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
// pub enum State {
//     Read,
//     Write,
// }

// #[derive(Clone, Debug)]
// pub struct Client {
//     pub readed: Vec<u8>,
//     pub state: State
// }

// impl Client {
//     fn new() -> Self {
//         Client {
//             readed: Vec::new(),
//             state: State::Read
//         }
//     }
// }

                    // println!("{:?}", clients.insert(client_fd, Client::new()));
                    // clients.insert(client_fd, Client::new());
                    // manager.add_client(client_fd, HttpClient::new(client_fd, EpollFlags::EPOLLIN));
                // let mut client = clients.get_mut(&cur_socket).unwrap();
                // let mut buf = [0;2048];
                // let mut b = false;
                // loop {
                //     let mut total_len = client.readed.len();
                //     let size = match read(cur_socket, &mut buf) {
                //         Ok(size) => {
                //             client.readed.extend_from_slice(&buf[..size]);
                //             if (size == 0) {
                //                 break;
                //             }
                //         },
                //         Err(Sys(err)) =>  {
                //             // print!("{:?}", e);
                //             if (err != Errno::EAGAIN)  {
                //                 print!("POPA1");
                //             }
                //             break;
                //         },
                //         Err(e) => {
                //             print!("POPA");
                //         }
                //     };
                // }

                // let req = std::str::from_utf8(&client.readed.as_slice()).unwrap().to_string();
                    
                // if !( req.find("\n\n").is_some() || req.find("\r\n\r\n").is_some() ){
                //     epoll_ctl(epfd, EpollOp::EpollCtlDel, cur_socket, &mut epoll_events[i]);
                //     close(cur_socket as i32)?;
                //     println!("clienrt {:?} request {}", cur_socket, req);
                //     continue;
                // }

                // let mut ev = EpollEvent::new(EpollFlags::EPOLLOUT, cur_socket as u64);
                // match epoll_ctl(epfd, EpollOp::EpollCtlMod, cur_socket, &mut ev) {
                //     Ok(e) => {},
                //     Err(err) => println!("Read ctl Err {:?}", err)
                // }

                // client.state = State::Write;
                // continue;


                    // println!("write");
                // let buf = "HTTP/1.1 200 Ok\nConnection: close\nContent-Type: text/plain\n\nha?\n\n";
                // let buf_len = buf.len();
                // let mut sended = 0;
                // let mut need_to_close = true;
                // // loop {
                //     match write(cur_socket, &buf.as_bytes()[sended..]) {
                //         Ok(len) => {
                //         //     if len == 0 {
                //         //         break;
                //         //     }
                //             sended += len;

                //                 need_to_close = true;

                //             if sended >=  buf_len {
                //                 need_to_close = true;
                //                 // break;
                //             }
                //         }, 
                //         Err(Sys(e)) => { 
                //             if (e != Errno::EAGAIN)  {
                //             print!("POPA");
                //             }
                //             // break;
                //         },
                //         Err(e) => {
                //             print!("{:?}", e);
                //         }
                //     }
                // }        



    // pub fn readHandler(&mut self) -> Result<ClientState, nix:Error> {
    //     match self.read() {
    //         Ok(state) => {
    //             if self.state != ClientState::ERROR {
    //                 if self.readed == 0 {
    //                     return 
    //                 }
    //             }
    //         }
    //     }
    // }



    // pub fn read(&mut self) -> Result<ClientState, io::Error> {
    //     if self.state == ClientState::START || self.state == ClientState::READING {
    //         self.state = ClientState::READING;
    //         let mut buf = [0; 8192];
    //         while true {
    //             match self.socket.read(&mut buf[0..8192]) {
    //                 Ok(len) =>  {
    //                     if len == 0 {
    //                         break;
    //                     }
    //                     self.readed += len;
    //                     self.buffer_read.extend_from_slice(&buf[0..len]);
    //                 }
    //                 Err(err) => {
    //                     if err.kind() == io::ErrorKind::WouldBlock {
    //                         break;
    //                     } else {
    //                         return Err(err);
    //                     }
    //                 }
    //             }
    //         }
    //     }

    //     let request_string = match str::from_utf8(self.buffer_read.as_slice()) {
    //         Ok(v) => v,
    //         Err(_) => panic!("Incorrect string format") // todo deregister or else send err
    //     };

    //     // todo loop accept
    //     self.req = match HttpRequest::parse(request_string) {
    //         Ok(http_request) => Some(http_request),
    //         Err(_) => None
    //     };
    //     self.state = ClientState::REQUEST_READED;
    //     self.interest.remove(Ready::readable());
    //     self.interest.insert(Ready::writable());
    //     return Ok(self.state.clone());
    // }

    // pub fn write(&mut self) -> Result<ClientState, io::Error> {
    //     if self.state == ClientState::REQUEST_READED {
    //         self.state = ClientState::WRITING;
    //         let mut response = self.process_request();
    //         let vec_rep = response.to_vec_response();
    //         self.len_write = vec_rep.len();
    //         self.buffer_write = vec_rep;
    //     }

    //     let batch_size = 16384;

    //     if self.writed < self.len_write {
    //         // println!("Written state {:?}", )
    //         self.state = ClientState::RESPONSE_WRITED;
    //         self.interest.remove(Ready::writable());

    //         let mut end;
    //         if self.len_write - self.len_write < batch_size {
    //             end = self.len_write;
    //         } else {
    //             end = self.writed + batch_size;
    //         }
    //         // match self.buffer_write.as_slice()[self.writed..end]) {                
    //         match self.socket.write(&self.buffer_write.as_slice()[self.writed..end]) {
    //             Ok(len) => {
    //                 self.writed += len;
    //             } 
    //             Err(err) => if err.kind() == io::ErrorKind::WouldBlock {
    //                 // println!("Write {:?}", err.kind());
    //                 return Ok(self.state.clone());
    //             } else {
    //                 panic!("{:?}", err);
    //             }
    //         }
    //         return Ok(self.state.clone());
    //     }
    //         self.interest.remove(Ready::writable());
    //         self.state = ClientState::RESPONSE_WRITED;
    //         return Ok(self.state.clone());

    //     // if self.state == ClientState::WRITING {
    //     //     while self.writed < self.len_write {
    //     //         let mut end;
    //     //         if self.len_write - self.len_write < batch_size {
    //     //             end = self.len_write;
    //     //         } else {
    //     //             end = self.writed + batch_size;
    //     //         }
    //     //         let bytes = &self.buffer_write.as_slice()[self.writed..end];
    //     //         // let io_vec: &IoVec = bytes.into();//[0, 16384].into;
    //     //         match self.socket.write(bytes) {
    //     //             Ok(len) => {
    //     //                 self.writed += len;
    //     //             },
    //     //             Err(err) => {
    //     //                 if err.kind() == io::ErrorKind::WouldBlock {
    //     //                     return Ok(self.state.clone());
    //     //                 } else {
    //     //                     return Err(err)
    //     //                 }
    //     //             }
    //     //         }
    //     //     }

    //     //     self.interest.remove(Ready::writable());
    //     //     self.state = ClientState::RESPONSE_WRITED;
    //     //     return Ok(self.state.clone());
    //     // }
    //     // return Ok(self.state.clone());
    // }











        // let mut ev = EpollEvent::new(EpollFlags::EPOLLOUT, cur_socket as u64);
        // match epoll_ctl(epfd, EpollOp::EpollCtlMod, cur_socket, &mut ev) {
        //     Ok(e) => {},
        //     Err(err) => println!("Read ctl Err {:?}", err)
        // }

        // client.state = State::Write;


            // }
            // if self.writed >= self.len_write {
            //     println!("Written state {:?}", )
            //     self.state = ClientState::RESPONSE_WRITED;
            //     self.interest.remove(Ready::writable());

            // match self.socket.write_bufs(&[&io_vec]) {//&self.buffer_write.as_slice()[self.writed..end]) {                
            //     // match self.socket.write(&self.buffer_write.as_slice()[self.writed..end]) {
            //         Ok(len) => {
            //             // if len == 0 {
            //             //     break;
            //             // }
            //             self.writed += len;

            //         } 
            //         Err(err) => if err.kind() == io::ErrorKind::WouldBlock {
            //             println!("Write {:?}", err.kind());
            //             return Ok(self.state.clone());
            //         } else {
            //             panic!("{:?}", err);
            //         }
            //     }


// pub fn read(&mut self) -> Result<ClientState, io::Error> {
//         if self.state == ClientState::START || self.state == ClientState::READING {
//             self.state = ClientState::READING;
//             let mut buf = [0; 8192];
//             let mut bytes = [0; 8192];
//             let mut io_vec = IoVec::from_bytes_mut(&mut bytes).unwrap();
//             // let buf: [IoVec]
//             // let mut buf = [0; 8192];
//             // let len = self.socket.read_bufs(&mut [io_vec]).unwrap();
//             // let buf = io_vec.as_bytes();
//         //     while true {
//         //         match self.socket.read(&mut buf[0..8192]) {
//         //             Ok(len) => {
//         //                 if len > 0 {
//         //                     self.readed += len;
//         //                     self.buffer_read.extend_from_slice(&buf[..len]);
//         //                     // return Ok(self.state.clone());
//         //                 } else {
//         //                     break
//         //                     self.state = ClientState::REQUEST_READED;
//         //                 }
//         //             },
//         //             Err (err) => { 
//         //                 if err.kind() == io::ErrorKind::WouldBlock {
//         //                     self.state = ClientState::REQUEST_READED;
//         //                     return Ok(self.state.clone());
//         //                 } else {
//         //                     return Err(err)
//         //                 }
//         //             }
//         //         }
//         //     }
//         // }
//             let mut state = io::ErrorKind::Other;
//             while true {//state != io::ErrorKind::WouldBlock {
//                 // self.socket.read_bufs;
//                 match self.socket.read_bufs(&mut [io_vec]) {
//                 // match self.socket.read(&mut buf[0..8192]) {
//                     Ok(len) =>  {
//                         if len == 0 {
//                             break;
//                         }
//                         self.readed += len;
//                         let buf = io_vec.as_bytes();
//                         self.buffer_read.extend_from_slice(&io_vec.as_bytes()[0..len]);
//                     }
//                     Err(err) => {
//                         // println!("Read err {:?}", err);
//                         if err.kind() == io::ErrorKind::WouldBlock {
//                             // println!("{:?}", err.kind());
//                             break;
//                             // return Ok(self.state.clone());
//                             // state = err.kind();
//                         } else {
//                             return Err(err);
//                             // let c = 1;
//                             // return;  // return error
//                         }
//                     }
//                 }
//             }
//         }
//         let request_string = match str::from_utf8(self.buffer_read.as_slice()) {
//             Ok(v) => v,
//             Err(_) => panic!("Incorrect string format") // todo deregister or else send err
//         };

//         // todo loop accept
//         self.req = match HttpRequest::parse(request_string) {
//             Ok(http_request) => Some(http_request),
//             Err(_) => None
//         };
//         self.state = ClientState::REQUEST_READED;
//         self.interest.remove(Ready::readable());
//         self.interest.insert(Ready::writable());
//         return Ok(self.state.clone());
//     }

            //     // let mut state = io::ErrorKind::Other;
            // // while true {//state != io::ErrorKind::WouldBlock {

            
            //     match self.socket.read(&mut buf[0..8192]) {
            //         Ok(len) =>  {
            //             if len > 0 {
            //                 self.readed += len;
            //                 self.buffer_read.extend_from_slice(&buf);
            //                 return Ok(self.state.clone());
            //             } 
            //         }
            //         Err(err) => {
            //             // println!("Read err {:?}", err);
            //             if err.kind() == io::ErrorKind::WouldBlock {
            //                 // println!("{:?}", err.kind());
            //                 // return Ok(self.state.clone());
            //                 // return Ok(self.state.clone());
            //                 // state = err.kind();
            //             } else {
            //                 return Err(err);
            //                 // let c = 1;
            //                 // return;  // return error
            //             }
            //         }
            //     }
            // // }



//   pub fn read(&mut self) -> Result<ClientState, io::Error> {
//         if self.state == ClientState::START || self.state == ClientState::READING {
//             self.state = ClientState::READING;
//             let mut bytes = [0; 8192];
//             let mut state = io::ErrorKind::Other;
//             match self.socket.read(&mut bytes) {
//                 Ok(len) =>  {
//                     self.readed += len;
//                     self.buffer_read.extend_from_slice(&bytes[0..len]);
//                     return Ok(self.state.clone());
//                 }
//                 Err(err) => {
//                     if err.kind() != io::ErrorKind::WouldBlock {
//                         return Err(err);
//                     }
//                 }
//             }
//         }

//         let request_string = match str::from_utf8(self.buffer_read.as_slice()) {
//             Ok(v) => v,
//             Err(_) => panic!("Incorrect string format") // todo deregister or else send err
//         };

//         // todo loop accept
//         self.req = match HttpRequest::parse(request_string) {
//             Ok(http_request) => Some(http_request),
//             Err(_) => None
//         };
//         self.state = ClientState::REQUEST_READED;
//         self.interest.remove(Ready::readable());
//         self.interest.insert(Ready::writable());
//         return Ok(self.state.clone());
//     }





# FROM ubuntu:18.04
# #
# # Установка postgresql
# #

# RUN apt-get -y update && apt-get install -y wget git && apt-get install curl -y && apt-get install build-essential -y

# USER root
# RUN mkdir /rust
# WORKDIR /rust
# RUN curl https://sh.rustup.rs -s >> rustup.sh
# RUN chmod 755 /rust/rustup.sh
# RUN ./rustup.sh -y
# ENV PATH=/root/.cargo/bin:$PATH SSL_VERSION=1.0.2h
# RUN apt-get remove --purge -y curl && apt-get autoclean && apt-get clean
# RUN rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*


# # Копируем исходный код в Docker-контейнер
# COPY httpd.conf /etc/httpd.conf
# ENV WORK /opt/rust_db
# ADD src/ $WORK/src/
# ADD V1__userinit.sql $WORK/schema.sql

# #RUN echo 'source $HOME/.cargo/env' >> $HOME/.bashrc
# #№RUN echo 'source $HOME/.cargo/env'
# # RUN ls -al /root
# #RUN echo $HOME
# #ADD install.sh $WORK/install.sh

# # install rust and cargo


# WORKDIR $WORK
# #RUN chmod +x install.sh && ./install.sh && rm install.sh

# ENV SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
# ADD Cargo.toml $WORK/Cargo.toml
# #RUN cargo update -p libc
# #RUN bash -c 'source $HOME/.cargo/env; cargo build -v --release'
# RUN cargo build -v --release

# EXPOSE 5000

# ENV PGPASSWORD 951103
# CMD service postgresql start && cd $WORK/ && psql -h localhost -U mavr -d test -f schema.sql && ./target/release/RustDb
